import{B as o}from"./BusinessCard-Di_B8Se3.js";import{getDB as n}from"./db-setup-CEBhzmfn.js";import{getStorageEstimate as x,initDB as I}from"./db-setup-CEBhzmfn.js";import{C as r}from"./CardImageId-9m3OyPHK.js";import"./Entity-DpinO5cs.js";import"./Result-BKWviScr.js";import"./Identifier-Yjt1Lx6E.js";import"./ValueObject-DRESENkS.js";class f{async findById(e){const a=await(await n()).get("cards",e.value);return a?this.toDomain(a):null}async findAll(){return(await(await n()).getAllFromIndex("cards","by-timestamp")).reverse().map(i=>this.toDomain(i)).filter(i=>i!==null)}async save(e){const t=await n(),a=this.toPersistence(e);await t.put("cards",a)}async delete(e){await(await n()).delete("cards",e.value)}async deleteMany(e){const a=(await n()).transaction("cards","readwrite");await Promise.all([...e.map(i=>a.store.delete(i.value)),a.done])}async exists(e){return await(await n()).get("cards",e.value)!==void 0}async count(){return await(await n()).count("cards")}async search(e){const t=await this.findAll();if(!e||e.trim().length===0)return t;const a=e.toLowerCase().trim();return t.filter(i=>[i.name,i.company,i.title,i.email,i.phone,i.address,i.website,i.contactInfo.socialMedia,i.contactInfo.fax].filter(Boolean).join(" ").toLowerCase().includes(a))}toPersistence(e){return{id:e.id.value,imageId:e.imageId.value,name:e.name,title:e.title,company:e.company,phone:e.phone,email:e.email,address:e.address,website:e.website,socialMedia:e.contactInfo.socialMedia,fax:e.contactInfo.fax,rawOcr:e.rawOcr,confidence:e.confidence,timestamp:e.timestamp,lastModified:e.lastModified}}toDomain(e){const t=o.from(e.id,e.imageId,{name:e.name,title:e.title,company:e.company,phone:e.phone,email:e.email,address:e.address,website:e.website,socialMedia:e.socialMedia,fax:e.fax},{rawText:e.rawOcr,confidence:e.confidence},{createdAt:new Date(e.timestamp),lastModified:new Date(e.lastModified),scanCount:1});return t.isFailure?(console.error("Failed to map record to domain entity:",t.error),null):t.value}}class y{async findById(e){const a=await(await n()).get("images",e.value);return a?this.toDomain(a):null}async save(e){const t=await n(),a=this.toPersistence(e),i=t.transaction("images","readwrite");await i.store.put(a),await i.done}async delete(e){await(await n()).delete("images",e.value)}async deleteMany(e){const a=(await n()).transaction("images","readwrite");await Promise.all([...e.map(i=>a.store.delete(i.value)),a.done])}async exists(e){return await(await n()).get("images",e.value)!==void 0}async getImageBlob(e){const t=await this.findById(e);return t?new Blob([t.image],{type:t.imageType}):null}async getThumbnailBlob(e){const t=await this.findById(e);return t?new Blob([t.thumbnail],{type:t.imageType}):null}toPersistence(e){return{id:e.id.value,image:e.image,thumbnail:e.thumbnail,imageType:e.imageType}}toDomain(e){return{id:r.from(e.id),image:e.image,thumbnail:e.thumbnail,imageType:e.imageType}}}export{f as IndexedDBBusinessCardRepository,y as IndexedDBCardImageRepository,n as getDB,x as getStorageEstimate,I as initDB};
